# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iXHBUumima2gdpBCWABZWAgUkWvuc3Qx
"""

import csv
import pandas as pd#pandas to create small dataframes 
import datetime #Convert to unix time
import time #Convert to unix time
# if numpy is not installed already : pip3 install numpy
import numpy as np#Do aritmetic operations on arrays
# matplotlib: used to plot graphs
import matplotlib
import matplotlib.pylab as plt
import seaborn as sns#Plots
from matplotlib import rcParams#Size of plots  
from sklearn.cluster import MiniBatchKMeans, KMeans#Clustering
import math
import pickle
import os
# to install xgboost: pip3 install xgboost
#import xgboost as xgb

import warnings
import networkx as nx
import pdb
import pickle
from pandas import HDFStore,DataFrame
from pandas import read_hdf
from scipy.sparse.linalg import svds, eigs
import gc
from tqdm import tqdm

# -*- coding: utf-8 -*-
import os
import codecs
def readfile(filename):
	#current_path=os.path.abspath(os.curdir)
	file_path=os.path.join("/content/drive/My Drive/SML_P1",filename)
	if not os.path.exists(file_path):
		print("error:file not found:"+filename)
		return ""
	f=codecs.open(file_path,"r","utf-8")
	s=f.read()
	f.close()
	return s
test_data=readfile("test-public.txt")
test_data=test_data.splitlines()
print("length of testing data:"+str(len(test_data)))
train_data=readfile("train.txt")
train_data=train_data.splitlines()
print("length of training data:"+str(len(train_data)))

train_list = []
for temp_str in train_data:
    temp = temp_str.split('\t')
    temp_list = [int(i) for i in temp]
    for i in range(1,len(temp_list)):
        train_list.append((temp_list[0], temp_list[i]))

"""# Graph

## Train data
"""

import numpy as np
positive_train = np.load("/content/drive/My Drive/SML_P1/positive_train_50k.npy").tolist()
negative_train = np.load("/content/drive/My Drive/SML_P1/negative_train_50k.npy").tolist()

print(len(negative_train))

print(positive_train[0:10])

"""## Test data"""

del test_data[0]

test_edges = []
for temp_str in test_data:
  temp = temp_str.split('\t')
  temp_list=[]
  temp_list.append(int(temp[1]))
  temp_list.append(int(temp[2]))
  test_edges.append(temp_list)

print(test_edges[0:10])

"""## Directed Graph"""

# import networkx as nx

# graph_data = []
# for temp_str in train_data:
#   temp = temp_str.split('\t')
#   temp_list = [int(i) for i in temp]
#   temp_edges = [(temp_list[0], temp_list[i]) for i in range(1, len(temp_list))]
#   #graph_data = graph_data + temp_edges
    
# DG=nx.DiGraph()
# for temp_edges in graph_data:
#   DG.add_edges_from(temp_edges)

##successful
import networkx as nx

DG=nx.DiGraph()
for temp_str in train_data:
  temp=temp_str.split('\t')
  temp_list=[int(i) for i in temp]
  temp_edges=[(temp_list[0], temp_list[i]) for i in range(1, len(temp_list))]
  DG.add_edges_from(temp_edges)

nx.info(DG)

print('number of nodes',DG.number_of_nodes())
print('number of edges',DG.number_of_edges())

#list(DG.successors(540762))

import networkx as nx

DGtest=nx.DiGraph()
for temp_str in train_data[0:3]:
  temp=temp_str.split('\t')[0:10]
  temp_list=[int(i) for i in temp]
  temp_edges=[(temp_list[0], temp_list[i]) for i in range(1, len(temp_list))]
  DGtest.add_edges_from(temp_edges)

import matplotlib.pyplot as plt
nx.draw(DGtest)

# DGtest.out_edges()
# DGtest.in_degree()

# DGtest.successors()
# DGtest.predecessors()

len(list(DGtest.successors(540762)))

#nx.jaccard_coefficient(DGtest, [(540762, 1912140)])

#list(DGtest.out_edges(540762))
#DGtest.out_degree(540762)

"""### Jaccard Distance"""

#for followees
def jaccard_for_followees(a,b):
    try:
        if len(set(DG.successors(a))) == 0  | len(set(DG.successors(b))) == 0:
            return 0
        sim = (len(set(DG.successors(a)).intersection(set(DG.successors(b)))))/\
                                    (len(set(DG.successors(a)).union(set(DG.successors(b)))))
    except:
        return 0
    return sim

print(jaccard_for_followees(540762, 1824878))

#for followers
def jaccard_for_followers(a,b):
    try:
        if len(set(DG.predecessors(a))) == 0  | len(set(DG.predecessors(b))) == 0:
            return 0
        sim = (len(set(DG.predecessors(a)).intersection(set(DG.predecessors(b)))))/\
                                 (len(set(DG.predecessors(a)).union(set(DG.predecessors(b)))))
        return sim
    except:
        return 0

print(jaccard_for_followers(540762, 1824878))

"""### Cosine distance"""

import math

#for followees
def cosine_for_followees(a,b):
    try:
        if len(set(DG.successors(a))) == 0  | len(set(DG.successors(b))) == 0:
            return 0
        sim = (len(set(DG.successors(a)).intersection(set(DG.successors(b)))))/\
                                    (math.sqrt(len(set(DG.successors(a)))*len((set(DG.successors(b))))))
        return sim
    except:
        return 0

(len(set(DG.successors(540762)).intersection(set(DG.successors(4008078)))))

math.sqrt(len(set(DG.successors(540762)))*len((set(DG.successors(4008078)))))

print(cosine_for_followees(540762, 4008078))

def cosine_for_followers(a,b):
    try:
        
        if len(set(DG.predecessors(a))) == 0  | len(set(DG.predecessors(b))) == 0:
            return 0
        sim = (len(set(DG.predecessors(a)).intersection(set(DG.predecessors(b)))))/\
                                     (math.sqrt(len(set(DG.predecessors(a))))*(len(set(DG.predecessors(b)))))
        return sim
    except:
        return 0

print(cosine_for_followers(540762, 1824878))

"""### Checking for same community"""

#if has direct edge then deleting that edge and calculating shortest path
def compute_shortest_path_length(a,b):
    p=-1
    try:
        if DG.has_edge(a,b):
            DG.remove_edge(a,b)
            p= nx.shortest_path_length(DG,source=a,target=b)
            DG.add_edge(a,b)
        else:
            p= nx.shortest_path_length(DG,source=a,target=b)
        return p
    except:
        return -1

#getting weekly connected edges from graph 
wcc=list(nx.weakly_connected_components(DG))
def belongs_to_same_wcc(a,b):
    index = []
    if DG.has_edge(b,a):
        return 1
    if DG.has_edge(a,b):
            for i in wcc:
                if a in i:
                    index= i
                    break
            if (b in index):
                DG.remove_edge(a,b)
                if compute_shortest_path_length(a,b)==-1:
                    DG.add_edge(a,b)
                    return 0
                else:
                    DG.add_edge(a,b)
                    return 1
            else:
                return 0
    else:
            for i in wcc:
                if a in i:
                    index= i
                    break
            if(b in index):
                return 1
            else:
                return 0

belongs_to_same_wcc(540762, 1824878)

belongs_to_same_wcc(1, 1824878)

"""### Adamic/Adar Index"""

#adar index
def calc_adar_in(a,b):
    sum=0
    try:
        n=list(set(DG.successors(a)).intersection(set(DG.successors(b))))
        if len(n)!=0:
            for i in n:
                sum=sum+(1/np.log10(len(list(DG.predecessors(i)))))
            return sum
        else:
            return 0
    except:
        return 0

calc_adar_in(540762, 1824878)

"""### followees_sim_C"""

from numpy import *

def followees_sim_C(a, b):
    feature=[0]*100
    i=0
    for temp_a in list(DG.successors(a)):
        feature[i] = cosine_for_followers(temp_a, b)
        i+=1
        if (i >= 100):
            break
    feature.sort(reverse=True)
    #mean(feature)
    #return mean(feature)
    return feature[0]

mean([1,4,2])

"""### followees_sim_J"""

def followees_sim_J(a, b):
    feature=[0]*100
    i=0
    for temp_a in list(DG.successors(a)):
        feature[i] = jaccard_for_followers(temp_a, b)
        i+=1
        if (i >= 100):
            break

    feature.sort(reverse=True)
    #mean(feature)
    #return mean(feature)
    return feature[0]

"""## Get features"""

def get_positive_features():
    features = []
    count = 0
    print("Generating positive features......")
    for temp_data in positive_train:
        #print(temp_data)
        if (count % 100 == 0):
            print(count)
        count += 1
        feature = []
        
        try:
#             a = jaccard_for_followees(temp_data[0],temp_data[1])
#             feature.append(a)
        
#             b = jaccard_for_followers(temp_data[0],temp_data[1])
#             feature.append(b)
        
#             c = cosine_for_followees(temp_data[0],temp_data[1])
#             feature.append(c)
        
#             d = cosine_for_followers(temp_data[0],temp_data[1])
#             feature.append(d)
        
            a = calc_adar_in(temp_data[0],temp_data[1])
            feature.append(a)

            b =  followees_sim_C(temp_data[0],temp_data[1])
            feature.append(b)
            
            c =  followees_sim_J(temp_data[0],temp_data[1])
            feature.append(c)
            

#             f = belongs_to_same_wcc(temp_data[0],temp_data[1])
#             feature.append(f)
            
            feature.append(1)  # label=1
            
        except:
            print("one error at: "+str(len(count)))
            print(temp_data)
            pass

        features.append(feature)
      
    print("positive features: "+str(len(features)))
    return features

#print(get_positive_features())

#positive_train[0:1]

def get_negative_features():
    features = []
    count = 0
    print("Generating negative features......")
    for temp_data in negative_train:
        if (count % 100 == 0):
            print(count)
        count += 1
        feature = []
        
        try:
#             a = jaccard_for_followees(temp_data[0],temp_data[1])
#             feature.append(a)
        
#             b = jaccard_for_followers(temp_data[0],temp_data[1])
#             feature.append(b)
        
#             c = cosine_for_followees(temp_data[0],temp_data[1])
#             feature.append(c)
        
#             d = cosine_for_followers(temp_data[0],temp_data[1])
#             feature.append(d)
        
#             e = calc_adar_in(temp_data[0],temp_data[1])
#             feature.append(e)

#             f =  followees_sim(temp_data[0],temp_data[1])
#             feature.append(f)

            a = calc_adar_in(temp_data[0],temp_data[1])
            feature.append(a)

            b =  followees_sim_C(temp_data[0],temp_data[1])
            feature.append(b)
            
            c =  followees_sim_J(temp_data[0],temp_data[1])
            feature.append(c)
            
#             f = belongs_to_same_wcc(temp_data[0],temp_data[1])
#             feature.append(f)
            
            feature.append(0)  # label=0
            
        except:
            print("one error at: "+str(len(count)))
            print(temp_data)
            pass
        
        features.append(feature)
    print("negative features: "+str(len(features)))
    return features

def get_test_features():
    features = []
    count = 0
    print("Generating test features......")
    for temp_data in test_edges:
        if (count % 100 == 0):
            print(count)
        count += 1
        feature = []

        try:
#             a = jaccard_for_followees(temp_data[0],temp_data[1])
#             feature.append(a)
        
#             b = jaccard_for_followers(temp_data[0],temp_data[1])
#             feature.append(b)
        
#             c = cosine_for_followees(temp_data[0],temp_data[1])
#             feature.append(c)
        
#             d = cosine_for_followers(temp_data[0],temp_data[1])
#             feature.append(d)
        
#             e = calc_adar_in(temp_data[0],temp_data[1])
#             feature.append(e)

#             f =  followees_sim(temp_data[0],temp_data[1])
#             feature.append(f)

            a = calc_adar_in(temp_data[0],temp_data[1])
            feature.append(a)

            b =  followees_sim_C(temp_data[0],temp_data[1])
            feature.append(b)
            
            c =  followees_sim_J(temp_data[0],temp_data[1])
            feature.append(c)
            
#             f = belongs_to_same_wcc(temp_data[0],temp_data[1])
#             feature.append(f)
            
            #feature.append(1)  # label=1
            
        except:
            print("one error at: "+str(len(count)))
            print(temp_data)
            pass

        features.append(feature)
        
    print("test features: "+str(len(features)))
    return features

"""### Generate features"""

train_features = get_positive_features() + get_negative_features()

test_features = get_test_features()

"""## Save"""

import csv

with open("/Users/tree/Desktop/train_50k_DG_3F.csv","w",newline="") as csvfile:
  writer=csv.writer(csvfile)
  writer.writerow(["AA","CS","JS","Label"])
  #writer.writerow(["J_Fee","J_Fer","C_Fee","C_Fer","AA","Label"])
  #writer.writerow(["RA","JC","AA","PA","CSH","RSH","WIC","Label"])
  writer.writerows(train_features)

import csv

with open("/Users/tree/Desktop/test_50k_DG_3F.csv","w",newline="") as csvfile:
  writer=csv.writer(csvfile)
  writer.writerow(["AA","CS","JS"])
  writer.writerows(test_features)